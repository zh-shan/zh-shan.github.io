import{_ as i,U as t,S as s,au as l}from"./chunks/framework.B7IDOeZq.js";const u=JSON.parse('{"title":"前端基础 CSS","description":"","frontmatter":{},"headers":[],"relativePath":"interview/css.md","filePath":"interview/css.md"}'),e={name:"interview/css.md"},o=l(`<h1 id="前端基础-css" tabindex="-1">前端基础 CSS <a class="header-anchor" href="#前端基础-css" aria-label="Permalink to &quot;前端基础 CSS&quot;">​</a></h1><h2 id="谈谈css的覆盖优先级" tabindex="-1">谈谈CSS的覆盖优先级 <a class="header-anchor" href="#谈谈css的覆盖优先级" aria-label="Permalink to &quot;谈谈CSS的覆盖优先级&quot;">​</a></h2><p><strong>引用方式的优先级（行内样式 &gt; (内部样式 = 外部样式)）</strong></p><ul><li>外部样式：通过 <code>&lt;link href=&quot;&quot; /&gt;</code> 标签引入外部CSS文件；</li><li>内部样式：在 <code>&lt;style&gt;&lt;/style&gt;</code> 标签内书写 CSS 代码；</li><li>行内样式：在标签上进行样式定义，如 <code>&lt;div style=&quot;&quot;&gt;&lt;/div&gt;</code></li></ul><p><strong>加载顺序的优先级</strong>：浏览器读取 CSS 的顺序是从上到下，这意味着，在发生冲突时，后定义的样式会覆盖先定义的，也就是“<strong>后来者居上</strong>”原则。</p><p><strong>选择器的优先级：</strong></p><ul><li>标签选择器、伪元素选择器：1；</li><li>类选择器、伪类选择器、属性选择器：10；</li><li>id 选择器：100；</li><li>行内样式：1000;</li></ul><p><strong>!important优先级最高</strong>：当在一个样式声明中使用一个 !important 规则时，此声明将覆盖任何其他声明。</p><h2 id="link和-import的区别" tabindex="-1">link和@import的区别 <a class="header-anchor" href="#link和-import的区别" aria-label="Permalink to &quot;link和@import的区别&quot;">​</a></h2><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h2 id="伪元素和伪类的区别和作用" tabindex="-1">伪元素和伪类的区别和作用？ <a class="header-anchor" href="#伪元素和伪类的区别和作用" aria-label="Permalink to &quot;伪元素和伪类的区别和作用？&quot;">​</a></h2><ul><li><strong>伪元素</strong>：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;第一章：&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hot!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::first-line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::first-letter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span></code></pre></div><ul><li><strong>伪类</strong>：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">#FF00FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:first-child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>总结：<strong>伪类是基于元素的状态或位置来选择元素并改变其样式。 伪元素则是在元素内部创建新的逻辑节点,并允许为这些虚构的节点添加样式或内容</strong>。</p><h2 id="css中可继承与不可继承属性有哪些" tabindex="-1">CSS中可继承与不可继承属性有哪些 <a class="header-anchor" href="#css中可继承与不可继承属性有哪些" aria-label="Permalink to &quot;CSS中可继承与不可继承属性有哪些&quot;">​</a></h2><p>每个 CSS 属性定义的概述都指出了这个属性是默认继承的 (&quot;Inherited: Yes&quot;) 还是默认不继承的 (&quot;Inherited: no&quot;)。这决定了当你没有为元素的属性指定值时该如何计算值。</p><p>当元素的一个继承属性（inherited property）没有指定值时，则取父元素的同属性的计算值（computed value）。只有文档根元素取该属性的概述中给定的初始值（initial value）（这里的意思应该是在该属性本身的定义中的默认值）。</p><p><strong>一、无继承性的属性</strong></p><ol><li><p><strong>display</strong>：规定元素应该生成的框的类型</p></li><li><p><strong>文本属性</strong>：</p></li></ol><ul><li><code>vertical-align</code>：垂直文本对齐</li><li><code>text-decoration</code>：规定添加到文本的装饰</li><li><code>text-shadow</code>：文本阴影效果</li><li><code>white-space</code>：空白符的处理</li><li><code>unicode-bidi</code>：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：<code>width</code>、<code>height</code>、<code>margin</code>、<code>border</code>、<code>padding</code></li><li><strong>背景属性</strong>：<code>background</code>、<code>background-color</code>、<code>background-image</code>、<code>background-repeat</code>、<code>background-position</code>、<code>background-attachment</code></li><li><strong>定位属性</strong>：<code>float</code>、<code>clear</code>、<code>position</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>、<code>min-width</code>、<code>min-height</code>、<code>max-width</code>、<code>max-height</code>、<code>overflow</code>、<code>clip</code>、<code>z-index</code></li><li><strong>生成内容属性</strong>：<code>content</code>、<code>counter-reset</code>、<code>counter-increment</code></li><li><strong>轮廓样式属性</strong>：<code>outline-style</code>、<code>outline-width</code>、<code>outline-color</code>、<code>outline</code></li><li><strong>页面样式属性</strong>：<code>size</code>、<code>page-break-before</code>、<code>page-break-after</code></li><li><strong>声音样式属性</strong>：<code>pause-before</code>、<code>pause-after</code>、<code>pause、cue-before</code>、<code>cue-after</code>、<code>cue</code>、<code>play-during</code></li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong>：</li></ol><ul><li><code>font-family</code>：字体系列</li><li><code>font-weight</code>：字体的粗细</li><li><code>font-size</code>：字体的大小</li><li><code>font-style</code>：字体的风格</li></ul><ol start="2"><li><strong>文本系列属性</strong>：</li></ol><ul><li><code>text-indent</code>：文本缩进</li><li><code>text-align</code>：文本水平对齐</li><li><code>line-height</code>：行高</li><li><code>word-spacing</code>：单词之间的间距</li><li><code>letter-spacing</code>：中文或者字母之间的间距</li><li><code>text-transform</code>：控制文本大小写（就是<code>uppercase</code>、<code>lowercase</code>、<code>capitalize</code>这三个）</li><li><code>color</code>：文本颜色</li></ul><ol start="3"><li><strong>元素可见性</strong>：</li></ol><ul><li><code>visibility</code>：控制元素显示隐藏</li></ul><ol start="4"><li><strong>列表布局属性</strong>：</li></ol><ul><li><code>list-style</code>：列表风格，包括<code>list-style-type</code>、<code>list-style-image</code>等</li></ul><ol start="5"><li><strong>光标属性</strong>：</li></ol><ul><li><code>cursor</code>：光标显示为何种形态</li></ul><h2 id="display的属性值及其作用" tabindex="-1">display的属性值及其作用 <a class="header-anchor" href="#display的属性值及其作用" aria-label="Permalink to &quot;display的属性值及其作用&quot;">​</a></h2><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table><h2 id="display的block、inline和inline-block的区别" tabindex="-1">display的block、inline和inline-block的区别 <a class="header-anchor" href="#display的block、inline和inline-block的区别" aria-label="Permalink to &quot;display的block、inline和inline-block的区别&quot;">​</a></h2><p></p><ol><li><strong>block</strong>：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</li><li><strong>inline</strong>：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li><strong>inline-block</strong>：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</li></ol><p>对于行内元素和块级元素，其特点如下：</p><p>（1）<strong>行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p>（2）<strong>块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h2 id="隐藏元素的方法有哪些" tabindex="-1">隐藏元素的方法有哪些 <a class="header-anchor" href="#隐藏元素的方法有哪些" aria-label="Permalink to &quot;隐藏元素的方法有哪些&quot;">​</a></h2><ul><li><code>display: none</code>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><code>visibility: hidden</code>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><code>opacity: 0</code>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><code>position: absolute</code>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><code>z-index: 负值</code>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><code>clip/clip-path </code>：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><code>transform: scale(0,0)</code>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h2 id="display-none与visibility-hidden的区别" tabindex="-1">display:none与visibility:hidden的区别 <a class="header-anchor" href="#display-none与visibility-hidden的区别" aria-label="Permalink to &quot;display:none与visibility:hidden的区别&quot;">​</a></h2><p>这两个属性都是让元素隐藏，不可见。两者区别如下：</p><ol><li><strong>在渲染树中</strong></li></ol><ul><li>display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li>visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><ol start="2"><li><strong>是否是继承属性</strong></li></ol><ul><li>display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li>visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</li></ul><ol start="3"><li><p>修改常规文档流中元素的 display 通常会造成文档的<strong>重排</strong>，但是修改visibility属性只会造成本元素的<strong>重绘</strong>；</p></li><li><p>如果使用读屏器，设置为display:none的<strong>内容不会被读取</strong>，设置为visibility:hidden的<strong>内容会被读取</strong>。</p></li></ol><h2 id="transition和animation的区别" tabindex="-1">transition和animation的区别 <a class="header-anchor" href="#transition和animation的区别" aria-label="Permalink to &quot;transition和animation的区别&quot;">​</a></h2><ul><li><p><strong>transition是过渡属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p></li><li><p><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p></li></ul><h2 id="对requestanimationframe的理解" tabindex="-1">对requestAnimationframe的理解 <a class="header-anchor" href="#对requestanimationframe的理解" aria-label="Permalink to &quot;对requestAnimationframe的理解&quot;">​</a></h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 <code>setTimeout</code> 来实现，CSS3 中可以使用 <code>transition</code> 和 <code>animation</code> 来实现，HTML5 中的 <code>canvas</code> 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 <code>requestAnimationFrame</code>，顾名思义就是请求动画帧。</p><blockquote><p>MDN对该方法的描述：</p><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p><strong>语法</strong>： <code>window.requestAnimationFrame(callback);</code> 其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p><p><strong>取消动画</strong>：使用<code>cancelAnimationFrame()</code>来取消执行动画，该方法接收一个参数：requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p><strong>优势</strong>：</p><ul><li><strong>CPU节能</strong>：使用 <code>setInterval</code> 实现的动画，当页面被隐藏或最小化时，setInterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而 requestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的 requestAnimationFrame 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，requestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>setTimeout任务被放入<strong>异步队列</strong>，只有当主线程任务执行完后才会执行队列中的任务，因此<strong>实际执行时间总是比设定时间要晚</strong>；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h2 id="对合子模型的理解" tabindex="-1">对合子模型的理解 <a class="header-anchor" href="#对合子模型的理解" aria-label="Permalink to &quot;对合子模型的理解&quot;">​</a></h2><p>盒模型都是由四个部分组成的，分别是 <code>margin</code>、<code>border</code>、<code>padding</code> 和 <code>content</code>。</p><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型。</p><p><strong>标准盒子模型</strong><img src="https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png" alt="标准盒子模型"></p><p>盒子总宽度 = width + padding + border + margin;</p><p>盒子总高度 = height + padding + border + margin;</p><p>标准盒模型的 width 和 height 属性的范围只包含了content，</p><p><strong>IE盒子模型</strong><img src="https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png" alt="IE盒子模型"></p><p>盒子总宽度 = width + margin;</p><p>盒子总高度 = height + margin;</p><p>IE盒模型的 width 和 height 属性的范围包含了 border、padding和content。</p><p>可以通过修改元素的 <code>box-sizing</code> 属性来改变元素的盒模型：</p><ul><li>box-sizing: content-box表示标准盒模型（默认值）</li><li>box-sizing: border-box表示IE盒模型（怪异盒模型）</li></ul><h1 id="margin-和-padding-的使用场景" tabindex="-1">margin 和 padding 的使用场景 <a class="header-anchor" href="#margin-和-padding-的使用场景" aria-label="Permalink to &quot;margin 和 padding 的使用场景&quot;">​</a></h1><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li></ul><h2 id="为什么有时候用translate而不是定位来改变位置" tabindex="-1">为什么有时候⽤translate⽽不是定位来改变位置？ <a class="header-anchor" href="#为什么有时候用translate而不是定位来改变位置" aria-label="Permalink to &quot;为什么有时候⽤translate⽽不是定位来改变位置？&quot;">​</a></h2><p>translate 是 transform 属性的⼀个值。</p><p>改变 transform 或 opacity 不会触发浏览器回流（reflow）或重绘（repaint），只会触发复合（compositions）。</p><p>⽽改变绝对定位会触发回流，进⽽触发重绘和复合。</p><p>transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。因此 translate() 更⾼效，可以缩短平滑动画的绘制时间。 ⽽ translate 改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h2 id="li-与-li-之间有看不见的空白间隔是什么原因引起的-如何解决" tabindex="-1">li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？ <a class="header-anchor" href="#li-与-li-之间有看不见的空白间隔是什么原因引起的-如何解决" aria-label="Permalink to &quot;li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？&quot;">​</a></h2><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个 &lt;li&gt;放在一行，这导致 &lt;li&gt; 换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><p><strong>解决办法</strong>：</p><ol><li>为 &lt;li&gt; 设置 <code>float:left</code>。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</li><li>将所有 &lt;li&gt; 写在同一行。不足：代码不美观。</li><li>将 &lt;ul&gt; 内的字符尺寸直接设为 0，即 <code>font-size:0</code>。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</li><li>消除 &lt;ul&gt; 的字符间隔 <code>letter-spacing:-8px</code>，不足：这也设置了 &lt;li&gt;内的字符间隔，因此需要将 &lt;li&gt;内的字符间隔设为默认<code>letter-spacing:normal</code>。</li></ol><h2 id="替换元素的概念及计算规则" tabindex="-1">替换元素的概念及计算规则 <a class="header-anchor" href="#替换元素的概念及计算规则" aria-label="Permalink to &quot;替换元素的概念及计算规则&quot;">​</a></h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是<strong>300像素×150像素</strong>，如 &lt;video&gt;、&lt;iframe&gt; 或者 &lt;canvas&gt; 等，也有少部分替换元素为 <strong>0 像素</strong>，如 &lt;img&gt; 图片，而表单元素的替换元素尺寸则和浏览器有关，没有明显的规律。</li><li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是 <code>vertical-align</code> 属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的 <code>baseline</code>，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li><strong>固有尺寸</strong>： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li><strong>HTML尺寸</strong>： 只能通过 HTML 原生属性改变，这些 HTML 原生属性包括 &lt;img&gt; 的 width 和 height 属性、 &lt;input&gt; 的size属性，&lt;textarea&gt; 的 cols 和 rows 属性。。</li><li><strong>CSS尺寸</strong>： 特指可以通过CSS的 <code>width</code> 和 <code>height</code> 或者 <code>max-width/min-width</code> 和 <code>max-height/min-height</code> 设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下：</p><ol><li>如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</li><li>如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</li><li>如果有CSS尺寸，则最终尺寸由CSS属性决定。</li><li>如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</li><li>如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</li><li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</li></ol><h2 id="常见的图片格式及使用场景" tabindex="-1">常见的图片格式及使用场景 <a class="header-anchor" href="#常见的图片格式及使用场景" aria-label="Permalink to &quot;常见的图片格式及使用场景&quot;">​</a></h2><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h2 id="对-csssprites-的理解" tabindex="-1">对 CSSSprites 的理解 <a class="header-anchor" href="#对-csssprites-的理解" aria-label="Permalink to &quot;对 CSSSprites 的理解&quot;">​</a></h2><p><strong>CSSSprites（精灵图）</strong>，将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 <code>background-image</code>，<code>background-repeat</code>，<code>background-position</code> 属性的组合进行背景定位。</p><p>优点：</p><ul><li>利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；</li><li>CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p>缺点：</p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。</li></ul><h2 id="什么是物理像素-逻辑像素和像素密度-为什么在移动端开发时需要用到-3x-2x这种图片" tabindex="-1">什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？ <a class="header-anchor" href="#什么是物理像素-逻辑像素和像素密度-为什么在移动端开发时需要用到-3x-2x这种图片" aria-label="Permalink to &quot;什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？&quot;">​</a></h2><p><strong>物理像素是设备屏幕（或图像）实际具有的像素数目，设备一出厂就确定的，固定的，是屏幕的最小物理单位。</strong></p><p><strong>逻辑像素就是css中设置的像素。默认情况下1物理像素 = 1逻辑像素, 在高像素密度的设备上1逻辑像素 = 多个物理像素。</strong></p><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV 元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p><p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p><blockquote><p>PPI：表示每英寸所包含的像素点数目，数值越高屏幕能以更高密度显示图像。</p><p>设备像素比（dpr）= 物理像素 / 逻辑像素</p></blockquote><p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500<em>300 像素，那么在 3 倍屏上就要放一个 1500</em>900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p><p>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p><p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">my-image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (low.png); }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@media</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> only</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> screen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (min-device-pixel-ratio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  #my-image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (high.png); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="对line-height-的理解及其赋值方式" tabindex="-1">对line-height 的理解及其赋值方式 <a class="header-anchor" href="#对line-height-的理解及其赋值方式" aria-label="Permalink to &quot;对line-height 的理解及其赋值方式&quot;">​</a></h2><p>用于设置多行元素的空间量（包含了字间距），如多行文本的间距，实际上是下一行基线到上一行基线距离，</p><ul><li>line-height 和 height 都能撑开一个高度；</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li></ul><p><code>line-height</code> 的赋值方式：</p><ul><li><strong>带单位</strong>：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li><strong>纯数字</strong>：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li><strong>百分比</strong>：将计算后的值传递给后代</li></ul><h2 id="css-优化和提高性能的方法有哪些" tabindex="-1">CSS 优化和提高性能的方法有哪些？ <a class="header-anchor" href="#css-优化和提高性能的方法有哪些" aria-label="Permalink to &quot;CSS 优化和提高性能的方法有哪些？&quot;">​</a></h2><p><strong>加载性能</strong>：</p><ol><li><strong>css压缩</strong>：将写好的css进行打包压缩，可以减小文件体积。</li><li><strong>css单一样式</strong>：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</li><li><strong>减少使用@import，建议使用link</strong>，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><p><strong>选择器性能</strong>：</p><ol><li><strong>关键选择器（key selector）</strong>。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。<strong>过滤掉无关的规则</strong>（这样样式系统就不会浪费时间去匹配它们了）。</li><li><strong>避免使用通配规则</strong>，如*{}计算次数惊人，只对需要用到的元素进行选择。</li><li><strong>尽量少的去对标签进行选择，而是用class</strong>。</li><li><strong>尽量少的去使用后代选择器</strong>，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后<strong>避免对可继承属性重复指定规则</strong>。</li></ol><p><strong>渲染性能</strong>：</p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ol><p><strong>可维护性、健壮性</strong>：</p><ol><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ol>`,136),a=[o];function n(r,d,p,c,h,g){return s(),t("div",null,a)}const b=i(e,[["render",n]]);export{u as __pageData,b as default};
