<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端基础 CSS | 技术加油站</title>
    <meta name="description" content="多年来一直奋斗在一线开发，此网站用于记录、总结和分享">
    <meta name="generator" content="VitePress v1.1.0">
    <link rel="preload stylesheet" href="/assets/style.2uSx2h8Q.css" as="style">
    
    <script type="module" src="/assets/app.DLFMRcD1.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.LfNDhxL3.js">
    <link rel="modulepreload" href="/assets/chunks/theme.Bl_V8hKZ.js">
    <link rel="modulepreload" href="/assets/interview_css.md.C1-BCtEB.lean.js">
    <link rel="icon" href="/images/favicon.svg">
    <script async src="https://hm.baidu.com/hm.js?052d62803ca32eed1e6ff7be29ef86d7"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar has-sidebar top" data-v-ae24b3ad data-v-ccf7ddec><div class="wrapper" data-v-ccf7ddec><div class="container" data-v-ccf7ddec><div class="title" data-v-ccf7ddec><div class="VPNavBarTitle has-sidebar" data-v-ccf7ddec data-v-ab179fa1><a class="title" href="/" data-v-ab179fa1><!--[--><!--]--><!--[--><img class="VPImage logo" src="/images/logo-icon.png" height="40" alt data-v-8426fc1a><!--]--><span data-v-ab179fa1>ZH-SHAN</span><!--[--><!--]--></a></div></div><div class="content" data-v-ccf7ddec><div class="content-body" data-v-ccf7ddec><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ccf7ddec><!--[--><!----><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ccf7ddec data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>主页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/sites.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>网址导航</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/tools.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>实用工具</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/share.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>知识小报</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/interview/html.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>前端知识</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/samples/queue.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>代码示例</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ccf7ddec data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="切换到深色模式" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-ccf7ddec data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zh-shan" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-ccf7ddec data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>主题</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="切换到深色模式" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zh-shan" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ccf7ddec data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-ccf7ddec><div class="divider-line" data-v-ccf7ddec></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-267dd0ed><button data-v-267dd0ed>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-575e6a36><div class="curtain" data-v-575e6a36></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-575e6a36><span class="visually-hidden" id="sidebar-aria-label" data-v-575e6a36> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-575e6a36><section class="VPSidebarItem level-0 has-active" data-v-575e6a36 data-v-b8d55f3b><!----><div class="items" data-v-b8d55f3b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/html.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>前端基础 HTML</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/css.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>前端基础 CSS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/javascript.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>前端基础 Javascript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/broswer.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>浏览器原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/vue.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>前端框架 Vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/nodejs.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>NodeJs 相关</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/engineering.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>前端工程化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/performance.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>前端性能优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/network.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>计算机网络</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/modes.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>设计模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/interview/algorithm.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>数据结构与算法</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-935f8a84><div class="content" data-v-935f8a84><div class="outline-marker" data-v-935f8a84></div><div class="outline-title" role="heading" aria-level="2" data-v-935f8a84>页面导航</div><nav aria-labelledby="doc-outline-aria-label" data-v-935f8a84><span class="visually-hidden" id="doc-outline-aria-label" data-v-935f8a84> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-935f8a84 data-v-b933a997><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _interview_css" data-v-39a288b8><div><h1 id="前端基础-css" tabindex="-1">前端基础 CSS <a class="header-anchor" href="#前端基础-css" aria-label="Permalink to &quot;前端基础 CSS&quot;">​</a></h1><blockquote><p>整个知识库涉及的资料一部分为自主收集整理，一部分来源于网络收集，如有侵权请联系我</p></blockquote><h2 id="谈谈css的覆盖优先级" tabindex="-1">谈谈CSS的覆盖优先级 <a class="header-anchor" href="#谈谈css的覆盖优先级" aria-label="Permalink to &quot;谈谈CSS的覆盖优先级&quot;">​</a></h2><p><strong>引用方式的优先级（行内样式 &gt; (内部样式 = 外部样式)）</strong></p><ul><li>外部样式：通过 <code>&lt;link href=&quot;&quot; /&gt;</code> 标签引入外部CSS文件；</li><li>内部样式：在 <code>&lt;style&gt;&lt;/style&gt;</code> 标签内书写 CSS 代码；</li><li>行内样式：在标签上进行样式定义，如 <code>&lt;div style=&quot;&quot;&gt;&lt;/div&gt;</code></li></ul><p><strong>加载顺序的优先级</strong>：浏览器读取 CSS 的顺序是从上到下，这意味着，在发生冲突时，后定义的样式会覆盖先定义的，也就是“<strong>后来者居上</strong>”原则。</p><p><strong>选择器的优先级：</strong></p><ul><li>标签选择器、伪元素选择器：1；</li><li>类选择器、伪类选择器、属性选择器：10；</li><li>id 选择器：100；</li><li>行内样式：1000;</li></ul><p><strong>!important优先级最高</strong>：当在一个样式声明中使用一个 !important 规则时，此声明将覆盖任何其他声明。</p><h2 id="link和-import的区别" tabindex="-1">link和@import的区别 <a class="header-anchor" href="#link和-import的区别" aria-label="Permalink to &quot;link和@import的区别&quot;">​</a></h2><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h2 id="伪元素和伪类的区别和作用" tabindex="-1">伪元素和伪类的区别和作用？ <a class="header-anchor" href="#伪元素和伪类的区别和作用" aria-label="Permalink to &quot;伪元素和伪类的区别和作用？&quot;">​</a></h2><ul><li><strong>伪元素</strong>：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;第一章：&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hot!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::first-line</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::first-letter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span></code></pre></div><ul><li><strong>伪类</strong>：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">#FF00FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:first-child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>总结：<strong>伪类是基于元素的状态或位置来选择元素并改变其样式。 伪元素则是在元素内部创建新的逻辑节点,并允许为这些虚构的节点添加样式或内容</strong>。</p><h2 id="css中可继承与不可继承属性有哪些" tabindex="-1">CSS中可继承与不可继承属性有哪些 <a class="header-anchor" href="#css中可继承与不可继承属性有哪些" aria-label="Permalink to &quot;CSS中可继承与不可继承属性有哪些&quot;">​</a></h2><p>每个 CSS 属性定义的概述都指出了这个属性是默认继承的 (&quot;Inherited: Yes&quot;) 还是默认不继承的 (&quot;Inherited: no&quot;)。这决定了当你没有为元素的属性指定值时该如何计算值。</p><p>当元素的一个继承属性（inherited property）没有指定值时，则取父元素的同属性的计算值（computed value）。只有文档根元素取该属性的概述中给定的初始值（initial value）（这里的意思应该是在该属性本身的定义中的默认值）。</p><p><strong>一、无继承性的属性</strong></p><ol><li><p><strong>display</strong>：规定元素应该生成的框的类型</p></li><li><p><strong>文本属性</strong>：</p></li></ol><ul><li><code>vertical-align</code>：垂直文本对齐</li><li><code>text-decoration</code>：规定添加到文本的装饰</li><li><code>text-shadow</code>：文本阴影效果</li><li><code>white-space</code>：空白符的处理</li><li><code>unicode-bidi</code>：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：<code>width</code>、<code>height</code>、<code>margin</code>、<code>border</code>、<code>padding</code></li><li><strong>背景属性</strong>：<code>background</code>、<code>background-color</code>、<code>background-image</code>、<code>background-repeat</code>、<code>background-position</code>、<code>background-attachment</code></li><li><strong>定位属性</strong>：<code>float</code>、<code>clear</code>、<code>position</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>、<code>min-width</code>、<code>min-height</code>、<code>max-width</code>、<code>max-height</code>、<code>overflow</code>、<code>clip</code>、<code>z-index</code></li><li><strong>生成内容属性</strong>：<code>content</code>、<code>counter-reset</code>、<code>counter-increment</code></li><li><strong>轮廓样式属性</strong>：<code>outline-style</code>、<code>outline-width</code>、<code>outline-color</code>、<code>outline</code></li><li><strong>页面样式属性</strong>：<code>size</code>、<code>page-break-before</code>、<code>page-break-after</code></li><li><strong>声音样式属性</strong>：<code>pause-before</code>、<code>pause-after</code>、<code>pause、cue-before</code>、<code>cue-after</code>、<code>cue</code>、<code>play-during</code></li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong>：</li></ol><ul><li><code>font-family</code>：字体系列</li><li><code>font-weight</code>：字体的粗细</li><li><code>font-size</code>：字体的大小</li><li><code>font-style</code>：字体的风格</li></ul><ol start="2"><li><strong>文本系列属性</strong>：</li></ol><ul><li><code>text-indent</code>：文本缩进</li><li><code>text-align</code>：文本水平对齐</li><li><code>line-height</code>：行高</li><li><code>word-spacing</code>：单词之间的间距</li><li><code>letter-spacing</code>：中文或者字母之间的间距</li><li><code>text-transform</code>：控制文本大小写（就是<code>uppercase</code>、<code>lowercase</code>、<code>capitalize</code>这三个）</li><li><code>color</code>：文本颜色</li></ul><ol start="3"><li><strong>元素可见性</strong>：</li></ol><ul><li><code>visibility</code>：控制元素显示隐藏</li></ul><ol start="4"><li><strong>列表布局属性</strong>：</li></ol><ul><li><code>list-style</code>：列表风格，包括<code>list-style-type</code>、<code>list-style-image</code>等</li></ul><ol start="5"><li><strong>光标属性</strong>：</li></ol><ul><li><code>cursor</code>：光标显示为何种形态</li></ul><h2 id="display的属性值及其作用" tabindex="-1">display的属性值及其作用 <a class="header-anchor" href="#display的属性值及其作用" aria-label="Permalink to &quot;display的属性值及其作用&quot;">​</a></h2><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table><h2 id="display的block、inline和inline-block的区别" tabindex="-1">display的block、inline和inline-block的区别 <a class="header-anchor" href="#display的block、inline和inline-block的区别" aria-label="Permalink to &quot;display的block、inline和inline-block的区别&quot;">​</a></h2><p></p><ol><li><strong>block</strong>：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</li><li><strong>inline</strong>：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li><strong>inline-block</strong>：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</li></ol><p>对于行内元素和块级元素，其特点如下：</p><p>（1）<strong>行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p>（2）<strong>块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h2 id="隐藏元素的方法有哪些" tabindex="-1">隐藏元素的方法有哪些 <a class="header-anchor" href="#隐藏元素的方法有哪些" aria-label="Permalink to &quot;隐藏元素的方法有哪些&quot;">​</a></h2><ul><li><code>display: none</code>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><code>visibility: hidden</code>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><code>opacity: 0</code>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><code>position: absolute</code>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><code>z-index: 负值</code>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><code>clip/clip-path </code>：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li><code>transform: scale(0,0)</code>：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h2 id="display-none与visibility-hidden的区别" tabindex="-1">display:none与visibility:hidden的区别 <a class="header-anchor" href="#display-none与visibility-hidden的区别" aria-label="Permalink to &quot;display:none与visibility:hidden的区别&quot;">​</a></h2><p>这两个属性都是让元素隐藏，不可见。两者区别如下：</p><ol><li><strong>在渲染树中</strong></li></ol><ul><li>display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li>visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><ol start="2"><li><strong>是否是继承属性</strong></li></ol><ul><li>display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li>visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</li></ul><ol start="3"><li><p>修改常规文档流中元素的 display 通常会造成文档的<strong>重排</strong>，但是修改visibility属性只会造成本元素的<strong>重绘</strong>；</p></li><li><p>如果使用读屏器，设置为display:none的<strong>内容不会被读取</strong>，设置为visibility:hidden的<strong>内容会被读取</strong>。</p></li></ol><h2 id="display-inline-block-什么时候会显示间隙" tabindex="-1">display:inline-block 什么时候会显示间隙？ <a class="header-anchor" href="#display-inline-block-什么时候会显示间隙" aria-label="Permalink to &quot;display:inline-block 什么时候会显示间隙？&quot;">​</a></h2><ul><li>有空格时会有间隙，可以删除空格解决；</li><li>margin正值时，可以让margin使用负值解决；</li><li>使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决</li></ul><h2 id="transition和animation的区别" tabindex="-1">transition和animation的区别 <a class="header-anchor" href="#transition和animation的区别" aria-label="Permalink to &quot;transition和animation的区别&quot;">​</a></h2><ul><li><p><strong>transition是过渡属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p></li><li><p><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p></li></ul><h2 id="对requestanimationframe的理解" tabindex="-1">对requestAnimationframe的理解 <a class="header-anchor" href="#对requestanimationframe的理解" aria-label="Permalink to &quot;对requestAnimationframe的理解&quot;">​</a></h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 <code>setTimeout</code> 来实现，CSS3 中可以使用 <code>transition</code> 和 <code>animation</code> 来实现，HTML5 中的 <code>canvas</code> 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 <code>requestAnimationFrame</code>，顾名思义就是请求动画帧。</p><blockquote><p>MDN对该方法的描述：</p><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p><strong>语法</strong>： <code>window.requestAnimationFrame(callback);</code> 其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p><p><strong>取消动画</strong>：使用<code>cancelAnimationFrame()</code>来取消执行动画，该方法接收一个参数：requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p><strong>优势</strong>：</p><ul><li><strong>CPU节能</strong>：使用 <code>setInterval</code> 实现的动画，当页面被隐藏或最小化时，setInterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而 requestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的 requestAnimationFrame 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，requestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>setTimeout任务被放入<strong>异步队列</strong>，只有当主线程任务执行完后才会执行队列中的任务，因此<strong>实际执行时间总是比设定时间要晚</strong>；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h2 id="对合子模型的理解" tabindex="-1">对合子模型的理解 <a class="header-anchor" href="#对合子模型的理解" aria-label="Permalink to &quot;对合子模型的理解&quot;">​</a></h2><p>盒模型都是由四个部分组成的，分别是 <code>margin</code>、<code>border</code>、<code>padding</code> 和 <code>content</code>。</p><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型。</p><p><strong>标准盒子模型</strong><img src="/images/knowledge/standard-box.png" alt="标准盒子模型"></p><p>盒子总宽度 = width + padding + border + margin;</p><p>盒子总高度 = height + padding + border + margin;</p><p>标准盒模型的 width 和 height 属性的范围只包含了content，</p><p><strong>IE盒子模型</strong><img src="/images/knowledge/ie-box.png" alt="IE盒子模型"></p><p>盒子总宽度 = width + margin;</p><p>盒子总高度 = height + margin;</p><p>IE盒模型的 width 和 height 属性的范围包含了 border、padding和content。</p><p>可以通过修改元素的 <code>box-sizing</code> 属性来改变元素的盒模型：</p><ul><li>box-sizing: content-box表示标准盒模型（默认值）</li><li>box-sizing: border-box表示IE盒模型（怪异盒模型）</li></ul><h2 id="margin-和-padding-的使用场景" tabindex="-1">margin 和 padding 的使用场景 <a class="header-anchor" href="#margin-和-padding-的使用场景" aria-label="Permalink to &quot;margin 和 padding 的使用场景&quot;">​</a></h2><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li></ul><h2 id="为什么有时候用translate而不是定位来改变位置" tabindex="-1">为什么有时候⽤translate⽽不是定位来改变位置？ <a class="header-anchor" href="#为什么有时候用translate而不是定位来改变位置" aria-label="Permalink to &quot;为什么有时候⽤translate⽽不是定位来改变位置？&quot;">​</a></h2><p>translate 是 transform 属性的⼀个值。</p><p>改变 transform 或 opacity 不会触发浏览器回流（reflow）或重绘（repaint），只会触发复合（compositions）。</p><p>⽽改变绝对定位会触发回流，进⽽触发重绘和复合。</p><p>transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。因此 translate() 更⾼效，可以缩短平滑动画的绘制时间。 ⽽ translate 改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h2 id="li-与-li-之间有看不见的空白间隔是什么原因引起的-如何解决" tabindex="-1">li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？ <a class="header-anchor" href="#li-与-li-之间有看不见的空白间隔是什么原因引起的-如何解决" aria-label="Permalink to &quot;li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？&quot;">​</a></h2><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个 &lt;li&gt;放在一行，这导致 &lt;li&gt; 换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><p><strong>解决办法</strong>：</p><ol><li>为 &lt;li&gt; 设置 <code>float:left</code>。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</li><li>将所有 &lt;li&gt; 写在同一行。不足：代码不美观。</li><li>将 &lt;ul&gt; 内的字符尺寸直接设为 0，即 <code>font-size:0</code>。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</li><li>消除 &lt;ul&gt; 的字符间隔 <code>letter-spacing:-8px</code>，不足：这也设置了 &lt;li&gt;内的字符间隔，因此需要将 &lt;li&gt;内的字符间隔设为默认<code>letter-spacing:normal</code>。</li></ol><h2 id="替换元素的概念及计算规则" tabindex="-1">替换元素的概念及计算规则 <a class="header-anchor" href="#替换元素的概念及计算规则" aria-label="Permalink to &quot;替换元素的概念及计算规则&quot;">​</a></h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是<strong>300像素×150像素</strong>，如 &lt;video&gt;、&lt;iframe&gt; 或者 &lt;canvas&gt; 等，也有少部分替换元素为 <strong>0 像素</strong>，如 &lt;img&gt; 图片，而表单元素的替换元素尺寸则和浏览器有关，没有明显的规律。</li><li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是 <code>vertical-align</code> 属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的 <code>baseline</code>，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li><strong>固有尺寸</strong>： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li><strong>HTML尺寸</strong>： 只能通过 HTML 原生属性改变，这些 HTML 原生属性包括 &lt;img&gt; 的 width 和 height 属性、 &lt;input&gt; 的size属性，&lt;textarea&gt; 的 cols 和 rows 属性。。</li><li><strong>CSS尺寸</strong>： 特指可以通过CSS的 <code>width</code> 和 <code>height</code> 或者 <code>max-width/min-width</code> 和 <code>max-height/min-height</code> 设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下：</p><ol><li>如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</li><li>如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</li><li>如果有CSS尺寸，则最终尺寸由CSS属性决定。</li><li>如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</li><li>如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</li><li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</li></ol><h2 id="常见的图片格式及使用场景" tabindex="-1">常见的图片格式及使用场景 <a class="header-anchor" href="#常见的图片格式及使用场景" aria-label="Permalink to &quot;常见的图片格式及使用场景&quot;">​</a></h2><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h2 id="对-csssprites-的理解" tabindex="-1">对 CSSSprites 的理解 <a class="header-anchor" href="#对-csssprites-的理解" aria-label="Permalink to &quot;对 CSSSprites 的理解&quot;">​</a></h2><p><strong>CSSSprites（精灵图）</strong>，将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 <code>background-image</code>，<code>background-repeat</code>，<code>background-position</code> 属性的组合进行背景定位。</p><p>优点：</p><ul><li>利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；</li><li>CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p>缺点：</p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li>CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。</li></ul><h2 id="什么是物理像素-逻辑像素和像素密度-为什么在移动端开发时需要用到-3x-2x这种图片" tabindex="-1">什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？ <a class="header-anchor" href="#什么是物理像素-逻辑像素和像素密度-为什么在移动端开发时需要用到-3x-2x这种图片" aria-label="Permalink to &quot;什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？&quot;">​</a></h2><p><strong>物理像素是设备屏幕（或图像）实际具有的像素数目，设备一出厂就确定的，固定的，是屏幕的最小物理单位。</strong></p><p><strong>逻辑像素就是css中设置的像素。默认情况下1物理像素 = 1逻辑像素, 在高像素密度的设备上1逻辑像素 = 多个物理像素。</strong></p><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV 元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p><p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p><blockquote><p>PPI：表示每英寸所包含的像素点数目，数值越高屏幕能以更高密度显示图像。</p><p>设备像素比（dpr）= 物理像素 / 逻辑像素</p></blockquote><p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500<em>300 像素，那么在 3 倍屏上就要放一个 1500</em>900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p><p>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p><p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">my-image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (low.png); }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@media</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> only</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> screen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (min-device-pixel-ratio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  #my-image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (high.png); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="对line-height-的理解及其赋值方式" tabindex="-1">对line-height 的理解及其赋值方式 <a class="header-anchor" href="#对line-height-的理解及其赋值方式" aria-label="Permalink to &quot;对line-height 的理解及其赋值方式&quot;">​</a></h2><p>用于设置多行元素的空间量（包含了字间距），如多行文本的间距，实际上是下一行基线到上一行基线距离，</p><ul><li>line-height 和 height 都能撑开一个高度；</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li></ul><p><code>line-height</code> 的赋值方式：</p><ul><li><strong>带单位</strong>：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li><strong>纯数字</strong>：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li><strong>百分比</strong>：将计算后的值传递给后代</li></ul><h2 id="z-index属性在什么情况下会失效" tabindex="-1">z-index属性在什么情况下会失效 <a class="header-anchor" href="#z-index属性在什么情况下会失效" aria-label="Permalink to &quot;z-index属性在什么情况下会失效&quot;">​</a></h2><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p>z-index属性在下列情况下会失效：</p><ul><li>父元素没有设置定位（position）属性，或者设置的值不是 relative, absolute, 或 fixed。</li><li>子元素的z-index属性值低于父元素</li><li>元素的透明度（opacity）小于1时，也可能导致z-index属性失效。</li><li>如果元素被设置为transform: translateZ(0)或will-change: transform，则可能会创建一个新的“层叠上下文”，从而导致z-index属性失效。</li></ul><h2 id="如何根据设计稿进行适配" tabindex="-1">如何根据设计稿进行适配？ <a class="header-anchor" href="#如何根据设计稿进行适配" aria-label="Permalink to &quot;如何根据设计稿进行适配？&quot;">​</a></h2><p>适配主要有两个维度：</p><ul><li>适配不同像素密度，针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li>适配不同屏幕大小，由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h2 id="常见的css布局单位" tabindex="-1">常见的CSS布局单位 <a class="header-anchor" href="#常见的css布局单位" aria-label="Permalink to &quot;常见的CSS布局单位&quot;">​</a></h2><p>常用的布局单位包括<strong>像素（px）</strong>，<strong>百分比（%）</strong>，<strong>em</strong>，<strong>rem</strong>，<strong>vw/vh</strong>。</p><p>（1）像素（px）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li>CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；</li><li>物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p>（2）百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p>（3）em和rem相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。</p><ul><li>em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li>rem： rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p>（4）vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p>vw/vh 和百分比很类似，两者的区别：</p><ul><li>百分比（%）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h2 id="px、em、rem的区别及使用场景" tabindex="-1">px、em、rem的区别及使用场景 <a class="header-anchor" href="#px、em、rem的区别及使用场景" aria-label="Permalink to &quot;px、em、rem的区别及使用场景&quot;">​</a></h2><p>三者的区别：</p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p>使用场景：</p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h2 id="两栏布局的实现" tabindex="-1">两栏布局的实现 <a class="header-anchor" href="#两栏布局的实现" aria-label="Permalink to &quot;两栏布局的实现&quot;">​</a></h2><p>一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应，两栏布局的具体实现：</p><ol><li><p>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</p></li><li><p>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</p></li><li><p>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</p></li><li><p>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</p></li><li><p>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</p></li></ol><h2 id="为什么需要清除浮动-清除浮动的方式" tabindex="-1">为什么需要清除浮动？清除浮动的方式 <a class="header-anchor" href="#为什么需要清除浮动-清除浮动的方式" aria-label="Permalink to &quot;为什么需要清除浮动？清除浮动的方式&quot;">​</a></h2><p>浮动的定义： 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p>浮动的工作原理：</p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p>浮动元素引起的问题？</p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p>清除浮动的方式如下：</p><ul><li>给父级div定义height属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式</li><li>包含浮动元素的父级标签添加overflow:hidden或者overflow:auto</li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix:after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\200B</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zoom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="使用-clear-属性清除浮动的原理" tabindex="-1">使用 clear 属性清除浮动的原理 <a class="header-anchor" href="#使用-clear-属性清除浮动的原理" aria-label="Permalink to &quot;使用 clear 属性清除浮动的原理&quot;">​</a></h2><p>使用clear属性清除浮动，其语法如下：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clear:none|left|right|both</span></span></code></pre></div><p>如果单看字面意思，<code>clear:left</code> 是“清除左浮动”，<code>clear:right</code> 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。</p><p>考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clear::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h2 id="对bfc的理解-如何创建bfc" tabindex="-1">对BFC的理解，如何创建BFC <a class="header-anchor" href="#对bfc的理解-如何创建bfc" aria-label="Permalink to &quot;对BFC的理解，如何创建BFC&quot;">​</a></h2><p>先来看两个相关的概念：</p><ul><li><strong>Box</strong>: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。</li><li><strong>Formatting context</strong>：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件</strong>：</p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption等；</li><li>overflow 值为：hidden、auto、scroll；</li><li>弹性元素(flex布局)；</li><li>网格元素(grid布局)；</li></ul><p><strong>BFC的特点</strong>：</p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触，即使浮动元素也是如此</li></ul><p><strong>BFC的作用</strong>：</p><ul><li><strong>解决margin重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置overflow:hidden。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  overflow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hidden</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> class=&quot;left&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> class=&quot;right&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h2 id="什么是margin重叠问题-如何解决" tabindex="-1">什么是margin重叠问题？如何解决？ <a class="header-anchor" href="#什么是margin重叠问题-如何解决" aria-label="Permalink to &quot;什么是margin重叠问题？如何解决？&quot;">​</a></h2><p><strong>问题描述</strong>： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。<strong>重叠只会出现在垂直方向</strong>。</p><p><strong>计算原则</strong>： 折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就取最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法</strong>： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠</p><p>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的 position 的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><h2 id="元素的层叠顺序" tabindex="-1">元素的层叠顺序 <a class="header-anchor" href="#元素的层叠顺序" aria-label="Permalink to &quot;元素的层叠顺序&quot;">​</a></h2><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="/images/knowledge/stacking-order.png" alt="元素层叠顺序"></p><p>对于上图，由上到下分别是：</p><ol><li>背景和边框：建立当前层叠上下文元素的背景和边框。</li><li>负的z-index：当前层叠上下文中，z-index属性值为负的元素。</li><li>块级盒：文档流内非行内级非定位后代元素。</li><li>浮动盒：非定位浮动元素。</li><li>行内盒：文档流内行内级非定位后代元素。</li><li>z-index:0：层叠级数为0的定位元素。</li><li>正z-index：z-index属性值为正的定位元素。</li></ol><blockquote><p><strong>注意</strong>: 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素</p></blockquote><h2 id="position的属性有哪些-区别是什么" tabindex="-1">position的属性有哪些，区别是什么 <a class="header-anchor" href="#position的属性有哪些-区别是什么" aria-label="Permalink to &quot;position的属性有哪些，区别是什么&quot;">​</a></h2><p>position有以下属性值：</p><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table><p>前面三者的定位方式如下：</p><ul><li><p>relative：元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。 <img src="/images/knowledge/relative.png" alt="相对定位"></p></li><li><p>fixed：元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。 <img src="/images/knowledge/fixed.png" alt="绝对定位-window"></p></li><li><p>absolute：元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示： <img src="/images/knowledge/absolute-to-parent.png" alt="绝对定位-父元素"><img src="/images/knowledge/absolute-to-screen.png" alt="绝对定位-浏览器"></p></li></ul><h2 id="display、float、position的关系" tabindex="-1">display、float、position的关系 <a class="header-anchor" href="#display、float、position的关系" aria-label="Permalink to &quot;display、float、position的关系&quot;">​</a></h2><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在的时候，浮动不起作用，&#39;display&#39;的值也需要调整；其次，元素的&#39;float&#39;特性的值不是&quot;none&quot;的时候或者它是根元素的时候，调整&#39;display&#39;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#39;display&#39;特性值同设置值。</p><h2 id="absolute与fixed共同点与不同点" tabindex="-1">absolute与fixed共同点与不同点 <a class="header-anchor" href="#absolute与fixed共同点与不同点" aria-label="Permalink to &quot;absolute与fixed共同点与不同点&quot;">​</a></h2><p>共同点：</p><ul><li>改变行内元素的呈现方式，将display置为inline-block</li><li>使元素脱离普通文档流，不再占据文档物理空间</li><li>覆盖非定位文档元素</li></ul><p>不同点：</p><ul><li>absolute与fixed的根元素不同，absolute的根元素可以设置，fixed根元素是浏览器。</li><li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li></ul><h2 id="对-sticky-定位的理解" tabindex="-1">对 sticky 定位的理解 <a class="header-anchor" href="#对-sticky-定位的理解" aria-label="Permalink to &quot;对 sticky 定位的理解&quot;">​</a></h2><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<code>position: sticky</code>; 基于用户的滚动位置来定位。</p><p>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</p><p>在目标区域以内，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed; 它会固定在目标位置。</p><p>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h2 id="css-优化和提高性能的方法有哪些" tabindex="-1">CSS 优化和提高性能的方法有哪些？ <a class="header-anchor" href="#css-优化和提高性能的方法有哪些" aria-label="Permalink to &quot;CSS 优化和提高性能的方法有哪些？&quot;">​</a></h2><p><strong>加载性能</strong>：</p><ol><li><strong>css压缩</strong>：将写好的css进行打包压缩，可以减小文件体积。</li><li><strong>css单一样式</strong>：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</li><li><strong>减少使用@import，建议使用link</strong>，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><p><strong>选择器性能</strong>：</p><ol><li><strong>关键选择器（key selector）</strong>。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。<strong>过滤掉无关的规则</strong>（这样样式系统就不会浪费时间去匹配它们了）。</li><li><strong>避免使用通配规则</strong>，如*{}计算次数惊人，只对需要用到的元素进行选择。</li><li><strong>尽量少的去对标签进行选择，而是用class</strong>。</li><li><strong>尽量少的去使用后代选择器</strong>，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后<strong>避免对可继承属性重复指定规则</strong>。</li></ol><p><strong>渲染性能</strong>：</p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ol><p><strong>可维护性、健壮性</strong>：</p><ol><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ol><h2 id="css预处理器-后处理器是什么-为什么要使用它们" tabindex="-1">CSS预处理器/后处理器是什么？为什么要使用它们？ <a class="header-anchor" href="#css预处理器-后处理器是什么-为什么要使用它们" aria-label="Permalink to &quot;CSS预处理器/后处理器是什么？为什么要使用它们？&quot;">​</a></h2><p><strong>预处理器</strong>，如：<code>less</code>，<code>sass</code>，<code>stylus</code>，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS，增加了css代码的复用性。层级，mixin， 变量，继承，循环， 函数等对编写以及开发UI组件都极为方便</p><p><strong>后处理器</strong>， 如：<code>postCss</code>，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p>css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。</p><p>使用原因：</p><ul><li>结构清晰，便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了CSS代码，可以应用到老项目中</li></ul><h2 id="详细对比各预处理器" tabindex="-1">详细对比各预处理器 <a class="header-anchor" href="#详细对比各预处理器" aria-label="Permalink to &quot;详细对比各预处理器&quot;">​</a></h2><ol><li>PostCSS</li></ol><p>PostCSS 是目前最为流行的 CSS 预/后处理器。PostCSS 本体功能比较单一，它提供一种用 JavaScript 来处理 CSS 的方式。PostCSS 会把 CSS 解析成 AST（Abstract Syntax Tree 抽象语法树），之后由其他插件进行不同的处理。</p><p><strong>功能</strong></p><p>PostCSS 本体功能比较单一，大多数的 CSS 处理功能都由插件提供，下面是一些常用的插件：</p><ul><li><code>Autoprefixer</code>：为 CSS 中的属性添加浏览器特定的前缀。</li><li><code>postcss-preset-env</code>：根据 browserslist 指定的目标浏览器将一些 CSS 的新特性转换为目标浏览器所支持的语法。</li><li><code>cssnano</code>：提供 CSS 压缩功能。</li><li><code>postcss-nested</code>：提供 CSS 嵌套功能。</li><li><code>postcss-px-to-viewport</code>：提供 px 转 vw 功能。</li><li><code>postcss-custom-properties</code>：支持 CSS 的自定义属性。</li></ul><p><strong>优点</strong></p><ul><li>插件系统完善，扩展性强。</li><li>配合插件功能齐全。</li><li>生态优秀。</li></ul><p><strong>缺点</strong></p><ul><li>配置相对复杂。</li></ul><ol start="2"><li>Sass</li></ol><p>Sass 在完全兼容 CSS 语法的前提下，给 CSS 提供了变量、嵌套、混合、操作符、自定义函数等可编程能力。</p><p><strong>功能</strong></p><p>Sass 常用的有几种功能：</p><ul><li>变量：变量中可以存储颜色、字体或任何 CSS 值。</li><li>嵌套：可嵌套 CSS 选择器，提供清晰的层次结构。</li><li>混合：可以定义&amp;重用代码块。</li><li>扩展/集成：可以在一个选择器内继承另一个选择器。</li><li>操作符：可以在 CSS 中使用操作符进行计算。</li><li>条件/循环语句：可以循环/条件生成 CSS。</li><li>自定义函数：可以自定义复杂操作的函数。</li></ul><p><strong>优点</strong></p><ul><li>使用广泛。</li><li>功能支持完善。</li><li>可编程能力强。</li></ul><p><strong>缺点</strong></p><ul><li>CSS 的复杂度不可控。</li><li>node-sass 国内安装不易（非 Sass 本身的缺点，dart-sass 可代替）。</li></ul><ol start="3"><li>Less</li></ol><p>Less 和 Sass 类似，完全兼容 CSS 语法，并给 CSS 提供了变量、嵌套、混合、运算等可编程能力。Less 通过 JavaScript 实现，可在浏览器端直接使用。</p><p><strong>功能</strong></p><p>Less 常用的有几种功能：</p><ul><li>变量：变量中可以存储颜色、字体或任何 CSS 值。</li><li>嵌套：可嵌套 CSS 选择器，提供清晰的层次结构。</li><li>混合：可以定义&amp;重用的代码块。</li><li>扩展/集成：可以在一个选择器内继承另一个选择器。</li><li>运算：可以在 CSS 中进行计算。</li><li>条件/循环语句：可以循环/条件生成 CSS。</li></ul><p><strong>优点</strong></p><ul><li>使用广泛。</li><li>可以在浏览器中运行，容易实现主题定制功能。</li></ul><p><strong>缺点</strong></p><ul><li>不支持自定义函数（可通过 mixins 实现简单逻辑）。</li><li>编程能力相对较弱。</li></ul><ol start="4"><li>Stylus</li></ol><p>Stylus 基础功能和 Sass / Less 十分类似。Stylus 的特点是冒号、分号、逗号和括号都是可选项，所以可以写出非常简洁的 CSS，示例如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>body</span></span>
<span class="line"><span>  background-color: #000</span></span>
<span class="line"><span></span></span>
<span class="line"><span>body::after</span></span>
<span class="line"><span>  content: &#39;HZFEStudio&#39;</span></span>
<span class="line"><span>  color: #fff</span></span>
<span class="line"><span>  font-size: 20px</span></span></code></pre></div><p>扩展阅读</p><ol><li>CSS Modules</li></ol><p>CSS Modules 和前文介绍的预处理器不同，不是可编程化的 CSS，而仅是给 CSS 文件加入了作用域和模块依赖，主要是为了解决 CSS 全局污染的痛点以及为了解决全局污染而嵌套过深的问题。使用示例如下：</p><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* style.css */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hzfeTitle {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: #</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">666</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  font</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: 20px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> style </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./style.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `&lt;h1 class=&quot;${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">style</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hzfeTitle</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;&gt;HZFEStudio&lt;/h1&gt;`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ol start="2"><li>CSS-in-JS</li></ol><p>如名字所见，CSS-in-JS 是一种在 JavaScript 里写 CSS 的方式。利用 JS 的优势可实现非常灵活的可扩展的样式。CSS-in-JS 有很多实现，目前比较流行的是 <code>Styled-components</code>。</p><p>通过 Styled-components 写 CSS 的示例如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;styled-components&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hzfe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styled.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">h1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    font-size: 1.5em;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    text-align: center;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    color: #666;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;HZFEStudio&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li>Tailwind 和 Utility-first CSS</li></ol><p>近几年随着 Tailwind 的流行，功能类优先（Utility-first CSS）的理念也再次流行起来。这里简单介绍一下 Tailwind CSS。</p><p>Tailwind CSS 是一个功能类优先的 CSS 框架，通过组合不同的类名实现页面设计。Tailwind 主要优势如下：</p><ul><li>不用考虑 class 的命名。</li><li>CSS 文件大小增长可控，通过 purge 可生成非常小的 CSS 文件。</li><li>统一设计系统下的样式与布局。</li><li>IDE 集成优秀。</li></ul><h2 id="对媒体查询的理解" tabindex="-1">对媒体查询的理解？ <a class="header-anchor" href="#对媒体查询的理解" aria-label="Permalink to &quot;对媒体查询的理解？&quot;">​</a></h2><p>媒体查询是CSS3引入的一种技术，允许开发者根据用户的设备特性应用不同的样式规则。它不仅可以检测设备的类型，还能检查诸如设备宽度、高度、分辨率等特性。通过媒体查询，可以实现同一页面在不同设备上呈现不同的布局。</p><p><strong>媒体类型（Media Types）</strong></p><p>媒体类型是媒体查询中的基础，它定义了应用媒体查询的设备类型。常见的媒体类型包括以下几种：</p><ul><li><code>all</code>：适用于所有设备，不限制设备类型。这是默认的媒体类型，即如果没有指定其他类型，媒体查询将应用于所有设备。</li><li><code>print</code>：用于打印机或打印预览时应用的样式。这种媒体类型在设计打印样式时非常有用，可以确保页面在打印时格式正确，隐藏一些不必要的内容，如导航栏等。</li><li><code>screen</code>：专为屏幕设备设计的样式，适用于电脑、平板、手机等显示屏幕的设备。</li><li><code>speech</code>：用于屏幕阅读器等有声设备，帮助为语音输出设备提供优化样式。</li></ul><h2 id="对-css-工程化的理解" tabindex="-1">对 CSS 工程化的理解 <a class="header-anchor" href="#对-css-工程化的理解" aria-label="Permalink to &quot;对 CSS 工程化的理解&quot;">​</a></h2><p>CSS 工程化是为了解决以下问题：</p><ol><li><strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li><li><strong>编码优化</strong>：怎样写出更好的 CSS？</li><li><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li><li><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li></ol><p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p><ul><li>预处理器：Less、 Sass 等；</li><li>重要的工程化插件： PostCss；</li><li>Webpack loader 等 。</li></ul><p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p><p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p><p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：</p><p><img src="/images/knowledge/preprocessor.png" alt="预处理器机制"></p><p>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p><ol><li>宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li><li>编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li><li>可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li></ol><p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p><ul><li>嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li><li>支持定义 css 变量；</li><li>提供计算函数；</li><li>允许对代码片段进行 extend 和 mixin；</li><li>支持循环语句的使用；</li><li>支持将 CSS 文件模块化，实现复用。</li></ul><p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p><p>PostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：</p><p>它和预处理器的不同就在于，预处理器处理的是 <code>类CSS</code>，而 PostCss 处理的就是 <code>CSS 本身</code>。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p><p>PostCss 在业务中的使用场景非常多：</p><ul><li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li><li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 Autoprefixer 插件可以帮助我们自动增加浏览器前缀；</li><li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li></ul><p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong></p><p>Webpack 能处理 CSS 吗：</p><ul><li>Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li><li>Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li></ul><p>如何用 Webpack 实现对 CSS 的处理：</p><ul><li>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li><li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情： <ul><li>css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li><li>style-loader：创建style标签，把 CSS 内容写入标签。</li></ul></li></ul><p>在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p><h2 id="画一条0-5px的线" tabindex="-1">画一条0.5px的线 <a class="header-anchor" href="#画一条0-5px的线" aria-label="Permalink to &quot;画一条0.5px的线&quot;">​</a></h2><ul><li>采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transform: scale(0</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, 0</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>采用meta viewport的方式</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果。</p><h2 id="设置小于12px的字体" tabindex="-1">设置小于12px的字体 <a class="header-anchor" href="#设置小于12px的字体" aria-label="Permalink to &quot;设置小于12px的字体&quot;">​</a></h2><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p>解决办法：</p><ul><li><p>使用Webkit的内核的 <code>-webkit-text-size-adjust</code> 的私有CSS属性来解决，只要加了 <code>-webkit-text-size-adjust:none;</code> 字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以<strong>高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式</strong>，所以要使用时候慎用。</p></li><li><p>使用css3的transform缩放属性<code>-webkit-transform:scale(0.5)</code>; 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；</p></li><li><p>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</p></li><li><p>zoom 的字面意思是“变焦”，可以改变页面上元素的尺寸，属于真实尺寸。其支持的值类型有：</p></li><li><p>zoom:50%，表示缩小到原来的一半</p></li><li><p>zoom:0.5，表示缩小到原来的一半 使用 zoom 来支持 12px 以下的字体</p></li></ul><h2 id="如何解决-1px-问题" tabindex="-1">如何解决 1px 问题？ <a class="header-anchor" href="#如何解决-1px-问题" aria-label="Permalink to &quot;如何解决 1px 问题？&quot;">​</a></h2><p>1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——<strong>CSS 中的 1px 并不能和移动设备上的 1px 划等号</strong>。它们之间的比例关系有一个专门的属性来描述：</p><blockquote><p><strong>window.devicePixelRatio = 设备的物理像素 / CSS像素。</strong></p></blockquote><p>解决1px 问题的三种思路：</p><ol><li>思路一：直接写 0.5px</li></ol><p>如果之前 1px 的样式这样写：border: 1px solid #333;</p><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;container&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> data-device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{window.devicePixelRatio}}&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为 2 的情况：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">#container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data-device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> #333</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><ol start="2"><li>思路二：伪元素先放大后缩小</li></ol><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">#container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data-device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">relative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">#container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data-device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">absolute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  transform-origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">left</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">border-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> #333</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li>思路三：viewport 缩放来解决</li></ol><p>这个思路就是对 meta 标签里几个关键属性下手：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.devicePixelRatio;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">metaEl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;content&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`width=device-width,user-scalable=no,initial-scale=${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scale</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">},maximum-scale=${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scale</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">},minimum-scale=${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scale</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p><h2 id="自适应的方案" tabindex="-1">自适应的方案 <a class="header-anchor" href="#自适应的方案" aria-label="Permalink to &quot;自适应的方案&quot;">​</a></h2></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-09de1c0f><!--[--><!--]--><!----><nav class="prev-next" data-v-09de1c0f><div class="pager" data-v-09de1c0f><a class="VPLink link pager-link prev" href="/interview/html.html" data-v-09de1c0f><!--[--><span class="desc" data-v-09de1c0f>上一页</span><span class="title" data-v-09de1c0f>前端基础 HTML</span><!--]--></a></div><div class="pager" data-v-09de1c0f><a class="VPLink link pager-link next" href="/interview/javascript.html" data-v-09de1c0f><!--[--><span class="desc" data-v-09de1c0f>下一页</span><span class="title" data-v-09de1c0f>前端基础 Javascript</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"O9AmDMBk\",\"interview_algorithm.md\":\"Cf39aant\",\"interview_broswer.md\":\"C2mHEKCz\",\"interview_codes.md\":\"D8gQCr-J\",\"interview_engineering.md\":\"C9D4LIgy\",\"interview_html.md\":\"rxg7cUm5\",\"interview_performance.md\":\"aa2hAWvu\",\"interview_modes.md\":\"Djh1flmu\",\"interview_network.md\":\"BEQJAUaF\",\"interview_nodejs.md\":\"DpvkVnYa\",\"interview_css.md\":\"C1-BCtEB\",\"interview_vue.md\":\"mkR_1mgr\",\"samples_queue.md\":\"BDLrynzn\",\"samples_sprites-to-svg.md\":\"DGNCIrMZ\",\"samples_undo-and-redo.md\":\"C_AYVjzt\",\"samples_watermark.md\":\"CbPoPras\",\"share_books.md\":\"B5j7RFa2\",\"sites.md\":\"B4CK-_ii\",\"interview_javascript.md\":\"pCdt7sYq\",\"tools_date.md\":\"kKTURU09\",\"share.md\":\"D4LTHy14\",\"tools.md\":\"MbAr11ij\",\"share_dependencies.md\":\"D2ZK3Eus\",\"tools_color.md\":\"DE4kluvV\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"技术加油站\",\"description\":\"多年来一直奋斗在一线开发，此网站用于记录、总结和分享\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":{\"src\":\"/images/logo-icon.png\",\"height\":40},\"siteTitle\":\"ZH-SHAN\",\"search\":{\"provider\":\"algolia\",\"options\":{\"appId\":\"EENQ6QK27C\",\"apiKey\":\"89b35ae14186f990337643aa48ce2dba\",\"indexName\":\"zh-shanio\",\"locales\":{\"zh\":{\"placeholder\":\"搜索文档\",\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"searchBox\":{\"resetButtonTitle\":\"清除查询条件\",\"resetButtonAriaLabel\":\"清除查询条件\",\"cancelButtonText\":\"取消\",\"cancelButtonAriaLabel\":\"取消\"},\"startScreen\":{\"recentSearchesTitle\":\"搜索历史\",\"noRecentSearchesText\":\"没有搜索历史\",\"saveRecentSearchButtonTitle\":\"保存至搜索历史\",\"removeRecentSearchButtonTitle\":\"从搜索历史中移除\",\"favoriteSearchesTitle\":\"收藏\",\"removeFavoriteSearchButtonTitle\":\"从收藏中移除\"},\"errorScreen\":{\"titleText\":\"无法获取结果\",\"helpText\":\"你可能需要检查你的网络连接\"},\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\",\"searchByText\":\"搜索提供者\"},\"noResultsScreen\":{\"noResultsText\":\"无法找到相关结果\",\"suggestedQueryText\":\"你可以尝试查询\",\"reportMissingResultsText\":\"你认为该查询应该有结果？\",\"reportMissingResultsLinkText\":\"点击反馈\"}}}}}}},\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"网址导航\",\"link\":\"/sites\"},{\"text\":\"实用工具\",\"link\":\"/tools\",\"activeMatch\":\"/tools\"},{\"text\":\"知识小报\",\"link\":\"/share\",\"activeMatch\":\"/share\"},{\"text\":\"前端知识\",\"link\":\"/interview/html\",\"activeMatch\":\"/interview/\"},{\"text\":\"代码示例\",\"link\":\"/samples/queue\",\"activeMatch\":\"/samples/\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/zh-shan\"}],\"sidebar\":{\"/samples/\":[{\"text\":\"并发队列\",\"link\":\"/samples/queue\"},{\"text\":\"撤销与重做\",\"link\":\"/samples/undo-and-redo\"},{\"text\":\"添加水印\",\"link\":\"/samples/watermark\"},{\"text\":\"Sprites逆向生成SVG\",\"link\":\"/samples/sprites-to-svg\"}],\"/interview/\":[{\"text\":\"前端基础 HTML\",\"link\":\"/interview/html\"},{\"text\":\"前端基础 CSS\",\"link\":\"/interview/css\"},{\"text\":\"前端基础 Javascript\",\"link\":\"/interview/javascript\"},{\"text\":\"浏览器原理\",\"link\":\"/interview/broswer\"},{\"text\":\"前端框架 Vue\",\"link\":\"/interview/vue\"},{\"text\":\"NodeJs 相关\",\"link\":\"/interview/nodejs\"},{\"text\":\"前端工程化\",\"link\":\"/interview/engineering\"},{\"text\":\"前端性能优化\",\"link\":\"/interview/performance\"},{\"text\":\"计算机网络\",\"link\":\"/interview/network\"},{\"text\":\"设计模式\",\"link\":\"/interview/modes\"},{\"text\":\"数据结构与算法\",\"link\":\"/interview/algorithm\"}]}},\"locales\":{\"root\":{\"label\":\"简体中文\",\"themeConfig\":{\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"langMenuLabel\":\"多语言\",\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"}}},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>